---
description: 
globs: 
alwaysApply: true
---
 # TASKS: Architectural Visualization Platform Build

**Project Goal:** Build a website to showcase architectural visualizations (3D scans, photogrammetry, AI imagery) using static embeds (Sketchfab, Vimeo) and image galleries. Plan for minimal client authentication later and potential future AI features (blog, chatbot). Low initial traffic expected.

**AI Assistant Guidance:** Please follow these tasks sequentially, adhering to all guidelines in @file:.cursor/rules/00_core_assistant_protocol.mdc and any technology-specific rules referenced or created. Await confirmation before proceeding to the next numbered task.

---

**Phase 1: Foundation & Backend Setup**

- [ ] **1.1 Environment Verification:** (User confirmed completed) Confirm necessary tools (Python 3.x, pip, Node.js LTS, npm, Git) are installed and report versions.
- [ ] **1.2 Backend Framework Decision & Scaffolding:**
    - **1.2.1 Recommendation:** Based on project goals and reviewed blueprints, recommend **either Django or Node.js/Express**. Justify the choice referencing built-in features (auth, admin), development speed, security, maintainability, and suitability for potential AI integration. Reference @file:.cursor/rules/00_core_assistant_protocol.mdc.
    - **1.2.2 Confirmation:** Await user confirmation.
    - **1.2.3 Scaffolding:** Upon confirmation:
        - Scaffold the chosen framework's project structure (e.g., `django-admin startproject config .` & `python manage.py startapp core` potentially in an `apps/` dir for Django; standard Express setup for Node).
        - Use the activated `.venv` for Python package installs (`pip install ...`).
        - Create/update `requirements.txt` or `package.json` with core dependencies.
        - Report created files/folders.
- [ ] **1.3 Configure Core Settings & Environment:**
    - **1.3.1 Env Package:** Install and configure environment variable loading (`django-environ` or `dotenv`). Update @file:.gitignore if needed.
    - **1.3.2 `.env.example` Check:** Ensure @file:.env.example contains placeholders for `SECRET_KEY`, `DEBUG=True`, `DATABASE_URL=sqlite:///db.sqlite3`.
    - **1.3.3 Framework Settings:** Configure the main settings file (`config/settings/base.py` or similar) to load these variables. Set `DEBUG` and `ALLOWED_HOSTS` (`['localhost', '127.0.0.1']` for dev).
    - **1.3.4 Database:** Configure the framework for SQLite dev database. Run initial migrations (e.g., `python manage.py migrate`). Verify success.
- [ ] **1.4 Create Foundational Framework Rules:**
    - **1.4.1 Create Rule File:** Create a *new* rule file in the appropriate subfolder, e.g., `.cursor/rules/backend/django_rules.mdc` or `.cursor/rules/backend/node_express_rules.mdc`.
    - **1.4.2 Populate Basic Rules:** Add foundational rules to this *new file*, including:
        - Preferred project structure (e.g., Django apps in `apps/`, Node modules).
        - Naming conventions (files, variables, classes).
        - View/Controller patterns (e.g., Class-Based Views vs Functions).
        - Basic framework-specific security reminders (CSRF, input validation).
        - **Include a simple code example** demonstrating the preferred style (e.g., a basic Django view or Express route handler).
    - **1.4.3 Reference Core Protocol:** Ensure this new rule file implicitly uses the core protocol (or add `@file:.cursor/rules/00_core_assistant_protocol.mdc` if needed, though broad globs might cover it).
- [ ] **1.5 Version Control Checkpoint:** Add all new/modified files (framework code, `.env.example` updates, new rule file) to Git staging. Generate a Conventional Commit message (e.g., "feat: Scaffold [Django/Node] backend, configure settings, add initial framework rules"). Await user confirmation to commit.

---

**Phase 2: Foundational Frontend Layout & Structure (Mobile-First)**

*AI Assistant Guidance: This phase establishes the core HTML structure and basic frontend configuration, guided by mobile-first principles and insights from design blueprints. Styling will be minimal; focus is on structure and semantics.*

- [ ] **2.1 Frontend Approach Decision & Validation:**
    - **2.1.1 Recommendation:** Based on the goal of displaying embedded content simply and efficiently, confirm that **Server-Side Rendering (SSR) using the backend framework's templating engine** (e.g., Django Templates) is the most suitable initial approach. Justify why a complex SPA framework is not needed now. Reference mobile-first best practices.
    - **2.1.2 Confirmation:** Await user confirmation.
- [ ] **2.2 Scaffold Core Frontend Directories & Files:**
    - **2.2.1 Create Directories:** Ensure the following standard directories exist: `templates/` (with a subdirectory for the core app, e.g., `templates/core/`), `static/`, `static/css/`, `static/js/`, `static/images/`.
    - **2.2.2 Create Base Files:** Create:
        - `templates/base.html` (with HTML5 boilerplate, viewport meta tag for responsiveness).
        - `templates/core/home.html` (initially empty or just extending base).
        - `static/css/style.css` (empty or with basic resets/body styles).
        - `static/js/script.js` (empty).
- [ ] **2.3 Implement Core Semantic Layout (`templates/base.html`):**
    - **2.3.1 Structure:** Implement the main page structure within `<body>` using semantic HTML5 elements:
        - `<header>`: Placeholder for logo and main navigation.
        - `<main>`: Primary content area. Include a content block placeholder (e.g., `{% block content %}{% endblock %}` for Django). Structure inner divs anticipating a simple grid/column layout later.
        - `<footer>`: Placeholder for copyright and secondary links.
    - **2.3.2 Mobile-First:** Ensure the structure is inherently mobile-friendly (e.g., linear flow, no fixed widths initially).
    - **2.3.3 Accessibility:** Use appropriate landmarks (`<nav>` within header, etc.).
- [ ] **2.4 Configure Static & Template File Serving:**
    - **2.4.1 Settings:** Configure the backend framework's settings (`settings.py` or equivalent) to correctly locate the `templates/` directory and the `static/` directory (`STATIC_URL`, `STATICFILES_DIRS`).
    - **2.4.2 Verification:** Briefly test if the development server can find and potentially serve `style.css` (even if empty) when linked from `base.html`. Report success or configuration needed.
- [ ] **2.5 Create Foundational Frontend Rules:**
    - **2.5.1 Create Rule File:** Create a *new* rule file: `.cursor/rules/frontend/01_layout_styling_base.mdc`.
    - **2.5.2 Populate Basic Rules:** Add foundational rules to this file, referencing the design blueprints:
        - **Guideline:** Enforce **Mobile-First** design approach for all layouts and CSS.
        - **Guideline:** Mandate use of **semantic HTML5** elements (`header`, `nav`, `main`, `footer`, `section`, `article`).
        - **Guideline:** Specify basic CSS structure (e.g., recommend CSS resets, basic `box-sizing: border-box;`).
        - **Guideline:** Note preference for CSS Grid/Flexbox for layout (to be detailed later).
        - **Guideline:** Include placeholder for typography rules (font stack, base size - e.g., 16px).
        - **Guideline:** Reference @file:templates/base.html as the core layout structure.
        - **Example:** Include a small HTML snippet showing correct semantic structure for the header/main/footer.
- [ ] **2.6 Version Control Checkpoint:** Stage all new/modified frontend files (templates, static files, settings changes) and the new frontend rule file. Generate a Conventional Commit message (e.g., "feat: Establish mobile-first frontend structure, base layout, static files config, and layout rules"). Await user confirmation to commit.

---

**Phase 3: Implement Homepage Content & Structure**

*AI Assistant Guidance: This phase focuses on structuring the homepage (`home.html`) and embedding the core placeholder content (3D models, videos, images). Apply semantic HTML and basic accessibility principles based on @file:.cursor/rules/frontend/01_layout_styling_base.mdc. Reference design blueprint concepts like Hero sections and F/Z patterns for logical placement.*

- [X] **3.1 Homepage Route & View Setup:** *(Assuming this was just completed)*
    - **3.1.1 Create URL:** Ensure a URL pattern for the root path (`/`) exists in `apps/core/urls.py` (or the relevant app's `urls.py`) and that it's included in the main `config/urls.py`.
    - **3.1.2 Create View:** Implement the corresponding view function/class (e.g., `HomePageView` in `apps/core/views.py`) that renders the `templates/core/home.html` template, ensuring it extends `templates/base.html`. Pass a basic page title in the context.
    - **3.1.3 Verify Basic Rendering:** Run the dev server. Access the homepage (`/`). Confirm the base layout (Header/Footer from `base.html`) renders without errors, even with an empty content block. Report success or errors.
- [ ] **3.2 Structure Homepage Content Area (`templates/core/home.html`):**
    - **3.2.1 Define Sections:** Within the `{% block content %}` of `home.html`, create primary content sections using semantic tags, considering a typical landing page flow (e.g., Hero, Portfolio/Gallery). Example:
        ```html
        <section id="hero" aria-labelledby="hero-heading">
          <h2 id="hero-heading" class="visually-hidden">Main Showcase</h2>
          <!-- Embeds will go here -->
        </section>
        <section id="image-gallery" aria-labelledby="gallery-heading">
          <h2 id="gallery-heading">Featured Images</h2>
          <!-- Image gallery will go here -->
        </section>
        ```
        *(Note: Define `visually-hidden` class in CSS later).*
    - **3.2.2 Placement Logic:** Briefly explain placement choices based on F/Z patterns (e.g., "Placing primary 3D embed in the #hero section for immediate focus").
- [ ] **3.3 Embed Sketchfab Model:**
    - **3.3.1 Add Embed Code:** In the `#hero` section, insert the placeholder Sketchfab `<iframe>` embed code.
    - **3.3.2 Accessibility:** Add a descriptive `title` attribute to the `<iframe>` (e.g., `title="Interactive 3D Model Viewer - Project Alpha"`).
- [ ] **3.4 Embed Vimeo Video:**
    - **3.4.1 Add Embed Code:** In an appropriate section, insert the placeholder Vimeo `<iframe>` embed code.
    - **3.4.2 Accessibility:** Add a descriptive `title` attribute to the `<iframe>` (e.g., `title="Project Alpha Walkthrough Video"`).
    - **3.4.3 Responsiveness (Basic):** Wrap the iframe in a `div` container and note the need for responsive CSS (padding-bottom trick) in comments within `style.css`.
- [ ] **3.5 Implement Static Image Gallery:**
    - **3.5.1 Add Images:** Ensure 1-2 placeholder `.jpg` or `.png` images exist in `static/images/`. If not, add them now.
    - **3.5.2 Create HTML Structure:** In the `#image-gallery` section, implement the gallery using semantic HTML (e.g., `<figure>` elements within a container).
    - **3.5.3 Display Images:** Use Django's `{% static %}` tag within `<img>` tags.
    - **3.5.4 Accessibility:** Provide meaningful `alt` text for each `<img>` tag.
- [ ] **3.6 Create Content Display Rules:**
    - **3.6.1 Create Rule File:** Create a *new* rule file: `.cursor/rules/frontend/02_content_embeds.mdc`.
    - **3.6.2 Populate Basic Rules:** Add rules to this file covering: `<iframe>` titles, `<img>` alt text, semantic structure for content blocks, placeholder for responsive embeds, placeholder for image optimization. Reference @file:.cursor/rules/frontend/01_layout_styling_base.mdc.
- [ ] **3.7 Verification:**
    - **3.7.1 Run Server:** Ensure dev server is running.
    - **3.7.2 Check Homepage:** Access homepage (`/`). Verify layout structure, iframes appear, images display, alt/title attributes are present via inspection.
    - **3.7.3 Report:** Confirm successful rendering and report any errors.
- [ ] **3.8 Version Control Checkpoint:** Stage changes (views, urls, templates, static images, new rule file). Generate commit message (e.g., "feat: Implement homepage content structure with placeholders"). Await confirmation to commit.

---

**Phase 4: Initial Styling, Navigation & Auth Prep**

*AI Assistant Guidance: This phase applies foundational styling using CSS (or optionally Tailwind CSS), makes navigation functional, and prepares the Django authentication structure.*

- [ ] **4.1 Styling Approach Decision:**
    - **4.1.1 Recommendation:** Recommend **either** basic custom CSS using `static/css/style.css` **or** integrating **Tailwind CSS** now. Justify based on project simplicity vs. utility-first speed/consistency advantages highlighted in blueprints. Mention that Tailwind requires Node.js build steps.
    - **4.1.2 Confirmation:** Await user confirmation.
- [ ] **4.2 Basic Styling Implementation:**
    - **4.2.1 CSS Setup:** If using custom CSS, apply basic styles in `static/css/style.css` for layout (`base.html` header/main/footer spacing, basic typography from rules), embeds (responsive iframe wrapper), and image gallery (`display: grid` or `flex` maybe). Reference @file:.cursor/rules/frontend/01_layout_styling_base.mdc.
    - **4.2.2 Tailwind Setup (If chosen):** If Tailwind is chosen:
        - Follow standard Tailwind+Django integration steps (install Node dependencies `tailwindcss`, `postcss`, `autoprefixer`; create `tailwind.config.js`, `postcss.config.js`, input CSS file `static/css/input.css`; configure Django template settings and static files build process).
        - Apply basic utility classes to `base.html` and `home.html` for layout spacing, background colors, and basic typography consistent with design blueprints.
        - Add relevant rules to a *new* file `.cursor/rules/frontend/03_tailwind_config.mdc`.
- [ ] **4.3 Implement Navigation:**
    - **4.3.1 Create Placeholder Pages:** Create basic view functions/classes and corresponding empty templates (extending `base.html`) for planned navigation links (e.g., About, Contact pages) in the `core` app. Add corresponding URL patterns in `apps/core/urls.py`.
    - **4.3.2 Update Header:** In `templates/base.html` (or a dedicated header template), make the navigation links functional using Django's `{% url '...' %}` template tag pointing to the names defined in `urls.py`.
    - **4.3.3 Verification:** Run dev server. Check that navigation links in the header work and load the (currently empty) placeholder pages.
- [ ] **4.4 Prepare Authentication Structure:**
    - **4.4.1 Create `accounts` App:** If not already present, create a dedicated Django app for authentication: `python manage.py startapp accounts` (place it inside `apps/` directory). Add `'apps.accounts'` to `INSTALLED_APPS` in settings.
    - **4.4.2 Configure Auth URLs:** In the main `config/urls.py`, include Django's built-in auth URLs: `path('accounts/', include('django.contrib.auth.urls')),`.
    - **4.4.3 Create Basic Auth Templates:** Create basic template files within `templates/registration/` (Django's default location for auth templates) for `login.html` and potentially `logged_out.html`. These can be very simple initially, extending `base.html` and containing the necessary form tags (`{% csrf_token %}` for login).
    - **4.4.4 Create Auth Rules:** Create a *new* rule file `.cursor/rules/backend/auth_rules.mdc`. Add basic rules: "Use Django's built-in auth system", "Place templates in `templates/registration/`", "Protect views with `@login_required` or `LoginRequiredMixin`".
    - **4.4.5 Verification:** Run dev server. Check if `/accounts/login/` URL loads the basic login template. (Actual login won't work fully without more setup, but the structure should be accessible).
- [ ] **4.5 Version Control Checkpoint:** Stage all changes (CSS/Tailwind config, templates, views, urls, settings updates, new rule files). Generate commit message (e.g., "feat: Implement initial styling, functional navigation, and auth structure prep"). Await user confirmation to commit.

---

**Phase 5: Enhance AI Assistant Capabilities (Memory & Core Tools)**

*AI Assistant Guidance: This phase upgrades the AI assistant with a persistent memory system and integrates essential MCP servers (GitHub, Browser Tools) to improve context, code management, and future verification capabilities. Follow instructions carefully regarding file creation, configuration, and rule definition.*

- [ ] **5.1 Implement Memory Bank System (Rules-Based Approach):**
    - **5.1.1 Create Structure:** Create the directory `memory-bank/` at the project root. Create initial Markdown files inside: `project_brief.md`, `active_context.md`, `progress_log.md`. *(Justification: Provides foundational persistent context as per memoryBank research).*
    - **5.1.2 Populate `project_brief.md`:** Draft content summarizing project goals, target audience, core features (visualization showcase, embeds), tech stack choices (once made), and key constraints. *Request AI assistance if needed.*
    - **5.1.3 Populate `active_context.md`:** Initialize with current state: "Completed Phase 4 (Initial Styling/Nav/Auth Prep). Starting Phase 5 (Memory/Tools Enhancement). Next: 5.1.4."
    - **5.1.4 Populate `progress_log.md`:** Initialize with summary: "Phase 1-4 completed: Backend scaffolded (Django), Frontend structure established, basic layout/content placeholders implemented, initial styling applied, navigation functional, auth structure prepped."
    - **5.1.5 Create Memory Bank Rule:** Create file `.cursor/rules/core/01_memory_bank_protocol.mdc`.
    - **5.1.6 Populate Memory Rule:** Add rules instructing AI on using the memory bank:
        - Guideline: "ALWAYS read @file:memory-bank/project_brief.md, @file:memory-bank/active_context.md, @file:memory-bank/progress_log.md at the start of complex tasks or new sessions."
        - Guideline: "Update @file:memory-bank/active_context.md with current focus/next steps after significant actions."
        - Guideline: "Log major completions, errors, or decisions in @file:memory-bank/progress_log.md."
        - Guideline: Define basic "Plan Mode" vs "Act Mode" distinction (Plan: strategy focus, update active_context; Act: execute task, update progress_log & active_context).
        - Set `ruleType: alwaysApply: true` for persistence.
    - **5.1.7 Update Core Protocol:** Modify @file:.cursor/rules/00_core_assistant_protocol.mdc to add: "Actively use and maintain the memory system defined in @file:.cursor/rules/core/01_memory_bank_protocol.mdc."

- [ ] **5.2 Setup GitHub MCP Server:**
    - **5.2.1 Create/Update `mcp.json`:** Create `.cursor/mcp.json` if it doesn't exist. Add the `mcpServers` structure.
    - **5.2.2 Configure GitHub MCP:** Add the configuration block for the GitHub MCP server to `mcp.json`. Refer to official MCP documentation or `@web https://github.com/modelcontextprotocol/servers/tree/main/src/github` for the exact `command`, `args`, and potentially needed `env` variables (like `GITHUB_TOKEN`).
    - **5.2.3 Update `.env.example`:** Add `GITHUB_TOKEN=` placeholder to @file:.env.example. Add a note that a personal access token with appropriate repo permissions is required in the actual `.env`.
    - **5.2.4 Verify Installation (If needed):** Run any necessary `npx` or install commands for the GitHub MCP server. Report success/failure.
    - **5.2.5 Create GitHub MCP Rule:** Create file `.cursor/rules/tools/github_mcp.mdc`.
    - **5.2.6 Populate Rule:** Add rules for GitHub MCP usage:
        - Guideline: "Use GitHub MCP for read operations (checking status, branches, history) when requested."
        - Guideline: "Use GitHub MCP for write operations (commit, push, create PR) **ONLY** when explicitly instructed and confirmed by the user."
        - Set `ruleType: agent-requested` with `description: Interact with the GitHub repository`.

- [ ] **5.3 Setup Browser Tools MCP Server (`AgentDeskAI/browser-tools-mcp`):**
    - **5.3.1 Configure Browser Tools MCP:** Add the configuration block for `browser-tools-mcp` to `.cursor/mcp.json`. Refer to `@web https://github.com/AgentDeskAI/browser-tools-mcp` for the required `command` (likely `npx -y @agentdesk/browser-tools-mcp`) and `args`. Check if any specific `env` variables are needed.
    - **5.3.2 Verify Installation (If needed):** Run any necessary installation commands. Report success/failure.
    - **5.3.3 Create Browser Tools Rule:** Create file `.cursor/rules/tools/browser_tools_mcp.mdc`.
    - **5.3.4 Populate Rule:** Add rules for Browser Tools MCP usage:
        - Guideline: "Use Browser Tools MCP when asked to: verify frontend rendering on a specific URL (local dev server or staging), check for JavaScript console errors, inspect basic layout elements, or scrape simple text content from a page."
        - Guideline: "State the URL you are accessing and the specific action (e.g., 'Checking console errors on localhost:8000')."
        - Guideline: "Do not attempt complex form submissions or interactions unless specifically instructed and confirmed."
        - Set `ruleType: agent-requested` with `description: Interact with web pages using browser automation tools`.

- [ ] **5.4 Update Core Protocol (Tools):** Modify @file:.cursor/rules/00_core_assistant_protocol.mdc to acknowledge the *specific* MCP tools available: "Utilize configured MCP servers (GitHub, Browser Tools) for relevant tasks as defined in their specific rules (@file:.cursor/rules/tools/...) when appropriate or requested."

- [ ] **5.5 Verification & Testing:**
    - **5.5.1 Memory Test:** Ask AI to recall information from `project_brief.md`. Verify correct retrieval.
    - **5.5.2 GitHub MCP Test:** Ask AI: "Using the GitHub MCP, what is the current Git branch name and its status?" Verify it attempts to use the tool. *(May require GITHUB_TOKEN setup).*
    - **5.5.3 Browser Tools Test (Deferred):** Plan to test this *after* Phase 3 is complete and the dev server can display the homepage. Task for later: "Using Browser Tools MCP, access `http://127.0.0.1:8000` (once running) and describe the text content inside the `<header>` element."

- [ ] **5.6 Version Control Checkpoint:** Stage all changes (`memory-bank/`, `mcp.json`, new rule files, `.env.example` updates, core protocol update). Generate commit message (e.g., "feat: Implement Memory Bank system & configure GitHub/Browser Tools MCPs"). Await confirmation to commit.

---




**(Further Phases: Styling with Tailwind/CSS, Authentication, Database Models, Deployment, AI Features will follow)**

